local json = import("./json.nlua")
local html = import("./parse_html.nlua")
local util = import("./util.nlua")
local type PageIndex = {[number] = {address = string}}
local type Page = {
	title = string,
	wikiName = string,
	wikiIcon = string,
	wikiUrl = string,
	address = string,
	createdTime = string,
	updateCount = number,
	markup = string,
	html = string,
	footer = string,
	revisionId = number,
	pageLinks = List<|
		{
			url = string,
			label = string,
			icon = string,
			description = string,
		}
	|>,
}

if not util.file_exists("./pages/index.json") then
	util.download("https://wiki.facepunch.com/gmod/~pagelist?format=json", "./pages/index.json")
end

local function build_from_pages()
	local T = {libraries = {}, structures = {}, enums = {}}
	local pages = json.decode(util.file_read("./pages/index.json")) as PageIndex

	do
		assert(pages[1].address == "")
		table.remove(pages, 1) -- remove the first page which is just the homepage
	end

	local function clean_default(str: nil | string)
		if not str then return end

		str = str:gsub("&%w+;", "")
		str = util.string_trim((str:gsub("=", "")))
		return str
	end

	local function find_type_from_description(type: string | nil, description: html.Tag | nil, page_link: string)
		if not type or type == "number" or type == "Panel" or type == "table" then
			local anchor = html.find_tag(description, "a")
			local href = anchor and anchor.attributes and anchor.attributes.href

			if href then
				if href:find("/gmod/D.-:") then return type end

				if href == "/gmod/Color" then
					return "Color"
				elseif href == "/gmod/Vector" then
					return "Vector"
				elseif href == "/gmod/Angle" then
					return "Angle"
				elseif href == "/gmod/VMatrix" then
					return "VMatrix"
				elseif href == "/gmod/string" then
					return "string"
				elseif href:find("/gmod/Enums/", nil, true) then
					return "Enum." .. href:sub(#"/gmod/Enums/" + 1)
				elseif href:find("/gmod/Structures", nil, true) then
					return href:sub(#"/gmod/Structures/" + 1)
				elseif href:find("/gmod/D", nil, true) then
					return href:sub(#"/gmod/" + 1)
				elseif href:find("/gmod/") then

				--print("not sure how to resolve generic ", type, " to ", href, " in page ", page_link)
				end
			end
		end

		return type
	end

	for _, page in ipairs(pages) do
		local url = "https://wiki.facepunch.com/gmod/" .. page.address .. "?format=json"
		local path = "./pages/" .. page.address .. ".json"

		if not util.file_exists(path) then util.download(url, path) end

		local page = json.decode(util.file_read(path)) as Page
		local root = html.parse(page.html)
		local node = html.find_node(root, "class", "")

		if node then
			local class = assert(node.attributes.class, "node has no class attribute")

			if class:sub(1, #"type") == "type" then
				local section = html.find_node(node, "class", "section")

				if section then
					local members
					local functions

					for _, child in ipairs(section.children) do
						if child.tag == "table" then
							local th = html.find_tag(child, "^th$")

							if th and html.select_first_data(th) == "Metamethod" then
								functions = html.find_tag(child, "tbody")
							else
								members = html.find_tag(child, "tbody")
							end
						end
					end

					if members then
						T.structures[page.address] = T.structures[page.address] or {members = {}, functions = {}}

						for _, child in ipairs(members.children) do
							local type = html.to_string(child.children[1])
							local name = html.to_string(child.children[2])
							local description = child.children[3]
							type = find_type_from_description(type, description, page.address)

							if name:find(" or ", nil, true) then
								for _, name in ipairs(util.string_split(name, "or")) do
									name = util.string_trim(name)
									T.structures[page.address].members[name] = {
										type = type,
										description = html.to_compact_html(description),
										default = clean_default(default),
									}
								end
							else
								T.structures[page.address].members[name] = {
									type = type,
									description = html.to_compact_html(description),
									default = clean_default(default),
								}
							end
						end
					end

					if functions then
						T.structures[page.address] = T.structures[page.address] or {members = {}, functions = {}}

						for _, child in ipairs(functions.children) do
							local name = html.to_string(child.children[1])
							local type = util.string_trim(html.to_string(child.children[2]))
							local description = child.children[3]
							local ret_type = find_type_from_description(nil, description, page.address)
							T.structures[page.address].functions[name] = {
								input = {
									type = type ~= "" and type or nil,
								},
								output = {type = ret_type or "any"},
								description = html.to_compact_html(description),
								default = clean_default(default),
							}
						end
					end
				end
			elseif class:sub(1, #"enum") == "enum" then
				local table_tag = assert(html.find_tag(node, "table"))
				local E = {}

				for i, tr in ipairs(table_tag.children) do
					local name = tr.children[1].children[2].children[1].data
					local value = tr.children[2].children[1].data
					local description = html.to_compact_html(tr.children[3])

					if name:find(" or ", nil, true) then
						for _, name in ipairs(util.string_split(name, "or")) do
							name = util.string_trim(name)
							table.insert(
								E,
								{
									name = name,
									value = value,
									description = description,
								}
							)
						end
					else
						table.insert(
							E,
							{
								name = name,
								value = value,
								description = description,
							}
						)
					end
				end

				local name = page.address:sub(#"Enums/" + 1)
				T.enums[name] = E
			elseif class:sub(1, #"struct") == "struct" then
				assert(node.children, "node has no children")
				local name = page.address:sub(#"Structures/" + 1)
				local S = T.structures[name] or {members = {}, functions = {}}

				for i, child in ipairs(node.children) do
					if child.attributes and child.attributes.class == "parameter" then
						local name = assert(html.select_first_data(html.find_tag(child, "strong")))
						local type = assert(html.select_first_data(html.find_tag(child, "a")))
						local description
						local default
						local description_node = html.find_node(child, "class", "description")
						type = find_type_from_description(type, description_node, page.address)

						if description_node then
							description = description_node.children[1] and
								html.to_compact_html(description_node.children[1])
							default = description_node.children[2] and
								description_node.children[2].children[2] and
								description_node.children[2].children[2].data
						end

						S.members[name] = {type = type, description = description, default = clean_default(default)}
					end
				end

				T.structures[name] = S
			elseif class:sub(1, #"function") == "function" then
				local class = assert(node.attributes.class)
				local classes = util.string_split(class, " ")
				table.remove(classes, 1) -- remove function
				local function_type = table.remove(classes, 1) -- remove function
				local realms = classes
				local F = {
					realms = realms,
					input = {},
					output = {},
				}

				do
					local node = html.find_node(node, "class", "function_arguments section")

					if node and node.children then
						for i, child in ipairs(node.children) do
							local name = html.select_first_data(html.find_node(child, "class", "name"))
							local type = html.select_first_data(html.find_node(child, "class", "link%-page"))
							local default = html.select_first_data(html.find_node(child, "class", "default"))
							local description = html.find_node(child, "class", "numbertagindent")
							type = find_type_from_description(type, description, page.address)

							if name then name = name:gsub("%s+", "_") end

							if type == "vararg" then
								name = "..."
								type = "...any"
							end

							F.input[i] = {
								name = name,
								type = type,
								default = clean_default(default),
								description = description and html.to_compact_html(description),
							}
						end
					end
				end

				do
					local node = html.find_node(node, "class", "function_returns section")

					if node and node.children then
						for i, child in ipairs(node.children) do
							local name = html.select_first_data(html.find_node(child, "class", "name"))
							local type = html.select_first_data(html.find_node(child, "class", "link%-page"))
							local description = html.find_node(child, "class", "numbertagindent")
							type = find_type_from_description(type, description, page.address)
							F.output[i] = {
								name = name,
								type = type,
								description = description and html.to_compact_html(description),
							}
						end
					end
				end

				local group, name = page.address:match("(.-)[%:%.](.*)")

				if not group then
					group = "Global"
					name = page.address
					print(page.address, "has no group")
				end

				if function_type == "panelfield" then
					T.structures[group] = T.structures[group] or {functions = {}, members = {}}
					T.structures[group].members[name] = F.output[1]
				elseif
					function_type == "classfunc" or
					function_type == "panelfunc" or
					function_type == "panelhook" or
					function_type == "hook"
				then
					T.structures[group] = T.structures[group] or {functions = {}, members = {}}
					T.structures[group].functions[name] = F
				else
					T.libraries[group] = T.libraries[group] or {functions = {}, type = function_type}
					T.libraries[group].functions[name] = F
				end
			end
		end
	end

	return T
end

local buffer = require("string.buffer" as string)
local T

if util.file_exists("./cache.dat") then
	T = buffer.decode(util.file_read("./cache.dat")) as return_type<|build_from_pages|>[0]
else
	T = build_from_pages()
	local buf = buffer.encode(T)
	util.file_write("./cache.dat", tostring(buf))
end

util.file_write("./output.json", json.encode(T))

local function sort(a, b)
	return a.key > b.key
end

local function to_list(map)
	local list = {}

	for k, v in pairs(map) do
		table.insert(list, {key = k, val = v})
	end

	table.sort(list, sort)
	return list
end

local function spairs(map)
	local list = to_list(map)
	local i = 0
	return function()
		i = i + 1

		if not list[i] then return end

		return list[i].key, list[i].val
	end
end

local nlua = {}
local i = 1
local write = function(s: string)
	nlua[i] = s
	i = i + 1
end
write("type Enum = {}\n")

for enum_group_name, enums in spairs(T.enums) do
	write("type Enum." .. enum_group_name .. " = enum<|{\n")

	for enum_name, enum in ipairs(enums) do
		enum.name = enum.name:gsub("%.", "_") -- TODO
		write("\t" .. enum.name .. " = " .. enum.value .. ",\n")
	end

	write("}|>\n")
end

for group_name, data in spairs(T.structures) do
	write("local type " .. group_name .. " = {}\n")
end

local function translate_type(t: string)
	if t == "function" then
		return "Function"
	elseif t == "table" then
		return "Table"
	end

	return t
end

local function write_tuple(tup)
	local s = ""

	for i, data in ipairs(tup) do
		local t = translate_type(data.type or "any")

		if data.default then t = "nil | " .. t end

		s = s .. t

		if i ~= #tup then s = s .. ", " end
	end

	return s
end

for group_name, data in spairs(T.structures) do
	write("do -- " .. group_name .. "\n")

	for name, data in spairs(data.members) do
		if tonumber(name) then
			name = "[" .. name .. "]"
		else
			name = "." .. name
		end

		write("\ttype " .. group_name .. name .. " = " .. translate_type(data.type) .. "\n")
	end

	for name, data in spairs(data.functions) do
		local input = data.input
		table.insert(input, 1, {type = group_name})
		write(
			"\ttype " .. group_name .. "." .. name .. " = function=(" .. write_tuple(input) .. ")>(" .. write_tuple(data.output) .. ")\n"
		)
	end

	write("end\n")
end

util.file_write("./output.nlua", table.concat(nlua))